---
category:
  - JS基础
---
# 7、执行栈和执行上下文.md
### 执行上下文
***JavaScript* 中执行环境**

1. 全局环境
2. 函数环境
3. *eval* 函数环境 （已不推荐使用）

那么与之对应的执行上下文类型同样有 *3* 种：

1. 全局执行上下文
2. 函数执行上下文
3. *eval* 函数执行上下文

*JavaScript* 运行时首先会进入全局环境，对应会生成全局上下文。程序代码中基本都会存在函数，那么**调用函数**，**就会**进入函数执行环境，对应就会生成该函数的执行上下文。

由于代码中会声明多个函数，对应的函数执行上下文也会存在多个。在 *JavaScript* 中，通过栈的存取方式来管理执行上下文，我们可称其为执行栈，或函数调用栈（*Call Stack*）。


### 栈数据结构
**执行栈（函数调用栈）**

理解完栈的存取方式，我们接着分析 *JavaScript* 中如何通过栈来管理多个执行上下文。

程序执行进入一个执行环境时，它的执行上下文就会被创建，并被推入执行栈中（入栈）；程序执行完成时，它的执行上下文就会被销毁，并从栈顶被推出（出栈），控制权交由下一个执行上下文。

因为 *JavaScript* 在执行代码时最先进入全局环境，所以**处于栈底的永远是全局环境的执行上下文**。而处于**栈顶的是当前正在执行函数的执行上下文**。

当函数调用完成后，它就会从栈顶被推出，理想的情况下，闭包会阻止该操作，闭包可以参阅《闭包》章节。

而全局环境只有一个，对应的全局执行上下文也只有一个，只有当页面被关闭之后它才会从执行栈中被推出，否则一直存在于栈底。

**执行上下文的数量限制（堆栈溢出）**

执行上下文可存在多个，虽然没有明确的数量限制，但如果超出栈分配的空间，会造成堆栈溢出。常见于递归调用，没有终止条件造成死循环的场景。

### 执行上下文生命周期

执行上下文的生命周期有两个阶段：

1. 创建阶段（**进入**执行上下文）：函数被调用时，进入函数环境，为其创建一个执行上下文，此时进入创建阶段。
2. 执行阶段（代码**执行**）：执行函数中代码时，此时执行上下文进入执行阶段。
**创建阶段**

创建阶段要做的事情主要如下：

1. 创建变量对象（*VO：variable object*）
   
   - 确定函数的形参（**并赋值**）
   
   - 函数环境会初始化创建 *Arguments*对象（**并赋值**）
   - 确定普通字面量形式的函数声明（**并赋值**）
   - 变量声明，函数表达式声明（**未赋值**）
   
2. 确定 *this* 指向（***this* 由调用者确定**）

3. 确定作用域（**词法环境决定，哪里声明定义，就在哪里确定**）



这里有必要说一下变量对象。

当处于执行上下文的建立阶段时，我们可以将整个上下文环境看作是一个对象。该对象拥有 *3* 个属性，如下：

```js
executionContextObj = {
    variableObject : {}, // 变量对象，里面包含 Arguments 对象，形式参数，函数和局部变量
    scopeChain : {},// 作用域链，包含内部上下文所有变量对象的列表
    this : {}// 上下文中 this 的指向对象
}
```

例子
```js
 const foo = function(i){
    console.log(b);
    console.log(c);   
     var a = "Hello";
    var b = function privateB(){};
     function c(){}
 }
 foo(10);
```
1、创建上下文阶段 
```js

fooExecutionContext = {
    // vo = {
    //     i : 10,
    //     arguments : {0 : 10, length : 1},
    //     c : 指向 c 那个函数
    //     a : undefined
    //     b : undefined
    // }
    // this,
    // scope
}
```
2、执行阶段
```js
    //     i : 10,
    //     arguments : {0 : 10, length : 1},
    //     c : 指向 c 那个函数
    //     a : undefined
    //     b : undefined
    // }
a ===> 'hello'
b: privateB 函数
```