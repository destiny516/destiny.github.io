---
star: true
category:
- JS基础
---
#  11、闭包
# 闭包



## 经典真题



- 闭包是什么？闭包的应用场景有哪些？怎么销毁闭包？



## 什么是闭包

闭包，是 *JavaScript* 中一个非常重要的知识点，也是我们前端面试中较高几率被问到的知识点之一。

打开《*JavaScript* 高级程序设计》和《 *JavaScript* 权威指南》，会发现里面针对闭包的解释各执一词，在网络上搜索关于闭包的内容，也发现众说纷纭，这就导致了这个知识点本身显得有点神秘，甚至还有一点玄幻。



那么这个知识点真的有那么深奥么？

非也！其实要理解 *JavaScript* 中的闭包，非常容易，但是在此之前你需要先知道以下两个知识点：

- *JavaScript* 中的作用域和作用域链
- *JavaScript* 中的垃圾回收



这里我们来简单回顾一下这两个知识点：

**1. *JavaScript* 中的作用域和作用域链**

- 作用域就是一个独立的地盘，让变量不会外泄、暴露出去，不同作用域下同名变量不会有冲突。
- 作用域在定义时就确定，并且不会改变。
- 如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。



**2. *JavaScript* 中的垃圾回收**

- *Javascript* 执行环境会负责管理代码执行过程中使用的内存，其中就涉及到一个垃圾回收机制
- 垃圾收集器会定期（周期性）找出那些不再继续使用的变量，只要该变量不再使用了，就会被垃圾收集器回收，然后释放其内存。如果该变量还在使用，那么就不会被回收。



*OK*，有了这 *2* 个知识点的铺垫后，接下来我们再来看什么是闭包。

 > 闭包不是一个具体的技术，而是一种现象，是指在定义函数时，周围环境中的信息可以在函数中使用。换句话说，执行函数时，只要在函数中使用了外部的数据，就创建了闭包。
>
> 而作用域链，正是实现闭包的手段。

```js
function eat(){
    var food = '鸡翅';
    return function(){
        console.log(food);
    }
}
var look = eat();
look(); // 鸡翅
look(); // 鸡翅
```

至此，闭包的一个优点或者特点也就体现出来了，那就是：

- 通过闭包可以让外部环境访问到函数内部的局部变量。
- 通过闭包可以让局部变量持续保存下来，不随着它的上下文环境一起销毁。


### 经典真题
```js
for (var i = 1; i <= 3; i++) {
    setTimeout(function () {
        console.log(i);
    }, 1000);
}
```

在上面的代码中，我们预期的结果是过 *1* 秒后分别输出 *i* 变量的值为 *1，2，3*。但是，执行的结果是：*4，4，4*。

实际上，问题就出在闭包身上。你看，循环中的 *setTimeout* 访问了它的外部变量 *i*，形成闭包。

而 *i* 变量只有 *1* 个，所以循环 *3* 次的 *setTimeout* 中都访问的是同一个变量。循环到第 *4* 次，*i* 变量增加到 *4*，不满足循环条件，循环结束，代码执行完后上下文结束。但是，那 *3* 个 *setTimeout* 等 *1* 秒钟后才执行，由于闭包的原因，所以它们仍然能访问到变量 *i*，不过此时 *i* 变量值已经是 *4* 了。

要解决这个问题，我们可以让 *setTimeout* 中的匿名函数不再访问外部变量，而是访问自己内部的变量，如下：

```js
for (var i = 1; i <= 3; i++) {
    (function (index) {
        setTimeout(function () {
            console.log(index);
        }, 1000);
    })(i)
}
```

这样 *setTimeout* 中就可以不用访问 *for* 循环声明的变量 *i* 了。而是采用调用函数传参的方式把变量 *i* 的值传给了 *setTimeout*，这样它们就不再创建闭包，因为在我自己的作用域里面能够找到 *i* 这个变量。

当然，解决这个问题还有个更简单的方法，就是使用 *ES6* 中的 *let* 关键字。

它声明的变量有块作用域，如果将它放在循环中，那么每次循环都会有一个新的变量 *i*，这样即使有闭包也没问题，因为每个闭包保存的都是不同的 *i* 变量，那么刚才的问题也就迎刃而解。

```js
for (let i = 1; i <= 3; i++) {
    setTimeout(function () {
        console.log(i);
    }, 1000);
}
```