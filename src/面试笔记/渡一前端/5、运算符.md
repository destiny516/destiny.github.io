---
star: true
category:
- JS基础
---
# 5、运算符.md

### 经典真题
- 下面代码中，*a* 在什么情况下会执行输出语句打印 *1* ？

```js
var a = ?;
if(a == 1 && a == 2 && a == 3){
 	console.log(1);
}
```

### 算数运算符
*JavaScript* 共提供 *10* 个算术运算符，用来完成基本的算术运算。
 
- **加法运算符**：`x + y`
- **减法运算符**： `x - y`
- **乘法运算符**： `x * y`
- **除法运算符**：`x / y`
- **指数运算符**：`x ** y`
- **余数运算符**：`x % y`
- **自增运算符**：`++x` 或者 `x++`
- **自减运算符**：`--x` 或者 `x--`
- **数值运算符**： `+x`
- **负数值运算符**：`-x`

#### 加法运算符
非数值（非字符串）会被转为数值
```js
true+true = 2
'3'+4+5 = '345'
[] + 1 = '1'
	Number([])//[]
	toStrding([])//''
{} + 1 = '[object Object]1'
	Number({})//{}
	toString({})//'[object Object]'
```
如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。

```js
1 + 'a' // "1a"
false + 'a' // "falsea"
```

加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。

```js
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
```
#### 余数运算符%
#### 自增自减 ++ --
 自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。

```javascript
var x = 1;
++x // 2
x // 2

--x // 1
x // 1
```

上面代码的变量`x`自增后，返回`2`，再进行自减，返回`1`。这两种情况都会使得，原始变量`x`的值发生改变。

运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。

自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。

```js
var i  = 1
var j  = ++i + 5
i//2
j//7

var i  = 1
var j  = i++ + 5
i//2
j//6
```

```javascript
var x = 1;
var y = 1;

x++ // 1
++y // 2
```
#### 数值运算符，负数值运算符

数值运算符（`+`）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。

数值运算符的作用在于可以将任何值转为数值（与`Number`函数的作用相同）。

```javascript
+true // 1
+[] // 0
-[]//-0
//[]转出来是0，是因为空数组在转字符串的时候是空字符串，字符串转为数字就是0
+{} // NaN
+{}//NaN
//{}转字符串都是得到的是[object Object]
```

#### 指数运算符

指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。

```javascript
2 ** 4 // 16
```

注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。

```javascript
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
```
#### 赋值运算符

赋值运算符（Assignment Operators）用于给变量赋值。

最常见的赋值运算符，当然就是等号（`=`）。

```javascript
// 将 1 赋值给变量 x
var x = 1;

// 将变量 y 的值赋值给变量 x
var x = y;
```

## 2. 比较运算符

比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件。

```
2 > 1 // true
```

上面代码比较`2`是否大于`1`，返回`true`。

> 注意，比较运算符可以比较各种类型的值，不仅仅是数值。

JavaScript 一共提供了8个比较运算符。

- `>` 大于运算符
- `<` 小于运算符
- `<=` 小于或等于运算符
- `>=` 大于或等于运算符
- `==` 相等运算符
- `===` 严格相等运算符
- `!=` 不相等运算符
- `!==` 严格不相等运算符

这八个比较运算符分成两类：相等比较和非相等比较。两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。

```js
//NaN 在做比较的时候一定得到的是false
//NaN 在做计算的时候得到的NaN

console.log(5 > NaN);//false
console.log(5 < NaN);//false
console.log(5 + NaN);//NaN
console.log(5 - NaN);//NaN
console.log(5 * NaN);//NaN
console.log(5 / NaN);//NaN
console.log(NaN === NaN);//false
```

#### 非相等运算符：字符串的比较

字符串按照字典顺序进行比较。 

#### 非相等运算符：非字符串的比较

如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。

**（1）原始类型值**

如果两个运算子都是原始类型的值，则是先转成数值再比较。
这里需要注意与`NaN`的比较。任何值（包括`NaN`本身）与`NaN`使用非相等运算符进行比较，返回的都是`false`。
**（2）对象**

如果运算子是对象，会转为原始类型的值，再进行比较。

对象转换成原始类型的值，算法是先调用`valueOf`方法；如果返回的还是对象，再接着调用`toString`方法，详细解释参见《数据类型的转换》一章。

#### 严格相等运算符

*JavaScript* 提供两种相等运算符：`==`和`===`。

简单说，它们的区别是相等运算符（`==`）比较两个值是否相等，严格相等运算符（`===`）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（`===`）直接返回`false`，而相等运算符（`==`）会将它们转换成同一个类型，再用严格相等运算符进行比较。
**（1）不同类型的值**

如果两个值的类型不同，直接返回`false`。

**（2）同一类的原始类型值**

同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回`true`，值不同就返回`false`。

**（3）复合类型值**

两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
```js
{} === {} // false
[] === [] // false
(function () {} === function () {}) // false
```
**（4）undefined 和 null**

`undefined`和`null`与自身严格相等。

```js
undefined === undefined // true
null === null // true
```
#### 严格不相等运算符

严格相等运算符有一个对应的“严格不相等运算符”（`!==`），它的算法就是先求严格相等运算符的结果，然后返回相反值。
#### 相等运算符

相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。

**（1）原始类型值**

原始类型的值会转换成数值再进行比较。

**（2）对象与原始类型值比较**

对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。

具体来说，先调用对象的`valueOf()`方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用`toString()`方法，得到字符串形式，再进行比较。
**（3）undefined 和 null**

`undefined`和`null`只有与自身比较，或者互相比较时，才会返回`true`；与其他类型的值比较时，结果都为`false`。

```js
undefined == undefined // true
null == null // true
undefined == null // true

false == null // false
false == undefined // false

0 == null // false
0 == undefined // false
```

**（4）相等运算符的缺点**

相等运算符隐藏的类型转换，会带来一些违反直觉的结果。

```js
0 == ''             // true
0 == '0'            // true

2 == true           // false
2 == false          // false

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```

上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（`==`），最好只使用严格相等运算符（`===`）。

#### 不相等运算符

相等运算符有一个对应的“不相等运算符”（`!=`），它的算法就是先求相等运算符的结果，然后返回相反值。


## 3. 布尔运算符（逻辑运算符）



布尔运算符用于将表达式转为布尔值，一共包含四个运算符。



- 取反运算符：`!`
- 且（并）运算符：`&&`
- 或运算符：`||`
- 三元运算符：`?:`

#### 取反运算符（!）

取反运算符是一个感叹号，用于将布尔值变为相反值，即`true`变成`false`，`false`变成`true`。

对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为`true`，其他值都为`false`。

- `undefined`
- `null`
- `false`
- `0`
- `NaN`
- 空字符串（`''`）

#### 且运算符（&&）

且运算符（`&&`）往往用于多个表达式的求值。

它的运算规则是：如果第一个运算子的布尔值为`true`，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为`false`，则直接返回第一个运算子的值，且不再对第二个运算子求值。

#### 或运算符（||）

或运算符（`||`）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为`true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为`false`，则返回第二个运算子的值。 

#### 三元条件运算符（?:）

三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为`true`，则返回第二个表达式的值，否则返回第三个表达式的值。

## 4. 位运算符

   
按位运算符是将操作数换算成 *32* 位的二进制整数，然后按每一位来进行运算。例如：

*5* 的 *32* 位为：

```
00000000000000000000000000000101
```

#### 按位非

按位非运算符`~`会把数字转为32位二进制整数，然后反转每一位。所有的 1 变为 0，所有的 0 变为 1

~5 的 32 位为：

```
11111111111111111111111111111010  
```

转换出来就为  -6

按位非，实质上是对操作数求负，然后减去1。

#### 按位与

按位或运算符`&`会把两个数字转为 32 位二进制整数，并对两个数的每一位执行按位与运算。按位与的规则如下表：

| 第一个数字 | 第二个数字 | 结果 |
| ---------- | ---------- | ---- |
| 1          | 1          | 1    |
| 1          | 0          | 0    |
| 0          | 1          | 0    |
| 0          | 0          | 0    |
#### 按位或

按位或运算符`|`会把两个数字转为 32 位二进制整数，并对两个数的每一位执行按位或运算。按位或的规则如下表：

| 第一个数字 | 第二个数字 | 结果 |
| ---------- | ---------- | ---- |
| 1          | 1          | 1    |
| 1          | 0          | 1    |
| 0          | 1          | 1    |
| 0          | 0          | 0    |

#### 按位异或

按位或运算符`^`会把两个数字转为 32 位二进制整数，并对两个数的每一位执行按位异或运算。运算规则为两位不同返回 1，两位相同返回 0，如下表：

| 第一个数字 | 第二个数字 | 结果 |
| ---------- | ---------- | ---- |
| 1          | 1          | 0    |
| 1          | 0          | 1    |
| 0          | 1          | 1    |
| 0          | 0          | 0    |
#### 按位移位

按位移位运算符`<<`和`>>`会将所有位向左或者向右移动指定的数量，实际上就是高效率地将数字乘以或者除以 2 的指定数的次方。

`<<`：乘以 2 的指定数次方

```js
console.log(2<<2); // 8
```
2 乘以 2 的 2 次方

00000010 转换为 00001000

`>>`：除以 2 的指定数次方

```js
console.log(16>>1); // 8
```

16 除以 2 的 1 次方

00010000转换为00001000

#### *void* 运算符

*void* 运算符的作用是执行一个表达式，然后不返回任何值，或者说返回 *undefined*。

#### 逗号运算符

逗号运算符用于对两个表达式求值，并返回后一个表达式的值。

## 6. 运算顺序

#### 优先级

*JavaScript* 各种运算符的优先级别（*Operator Precedence*）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行。

#### 圆括号的作用

圆括号可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。

#### 左结合和右结合

对于优先级别相同的运算符，同时出现的时候，就会有计算顺序的问题。