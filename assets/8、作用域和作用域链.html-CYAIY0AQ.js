import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as a,a as s}from"./app-x8bEfOWx.js";const t={},p=s(`<h1 id="_8、作用域和作用域链-md" tabindex="-1"><a class="header-anchor" href="#_8、作用域和作用域链-md"><span>8、作用域和作用域链.md</span></a></h1><h2 id="作用域-scope" tabindex="-1"><a class="header-anchor" href="#作用域-scope"><span>作用域（<em>Scope</em>）</span></a></h2><h3 id="什么是作用域" tabindex="-1"><a class="header-anchor" href="#什么是作用域"><span>什么是作用域</span></a></h3><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。 换句话说，作用域决定了代码区块中变量和其他资源的可见性。</p><p>作用域就是一个独立的地盘，让变量不会<strong>外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong><strong><em>ES6</em> 之前 <em>JavaScript</em> 没有块级作用域，只有全局作用域和函数作用域</strong>。</p><p><em>ES6</em> 的到来，为我们提供了“块级作用域”，可通过新增命令 <em>let</em> 和 <em>const</em> 来体现。</p><h3 id="全局作用域和函数作用域" tabindex="-1"><a class="header-anchor" href="#全局作用域和函数作用域"><span>全局作用域和函数作用域</span></a></h3><p><strong>（1）全局作用域</strong></p><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p><ul><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li><li><ul><li>所有未定义直接赋值的变量自动声明为拥有全局作用域</li></ul></li><li><ul><li>所有 <em>window</em> 对象的属性拥有全局作用域</li></ul></li></ul><p>一般情况下，<em>window</em> 对象的内置属性都拥有全局作用域，例如 <em>window.name、window.location、window.top</em> 等等。</p><p>全局作用域有个弊端：如果我们写了很多行 <em>JS</em> 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会污染全局命名空间， 容易引起命名冲突。 这就是为何 <em>jQuery、Zepto</em> 等库的源码，所有的代码都会放在 <em>(function(){....})( )</em> 中。</p><p><strong>（2）函数作用域</strong></p><p>函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。 <strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong>。</p><h3 id="块级作用域" tabindex="-1"><a class="header-anchor" href="#块级作用域"><span>块级作用域</span></a></h3><p>块级作用域可通过新增命令 <em>let</em> 和 <em>const</em> 声明，所声明的变量在指定块的作用域外无法被访问。</p><p>块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol><p><em>let</em> 声明的语法与 <em>var</em> 的语法一致。你基本上可以用 <em>let</em> 来代替 <em>var</em> 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p><ul><li>声明变量不会提升到代码块顶部</li></ul><p><em>let、const</em> 声明并不会被提升到当前代码块的顶部，因此你需要手动将 <em>let、const</em> 声明放置到顶部，以便让变量在整个代码块内部可用。</p><ul><li>禁止重复声明</li></ul><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 <em>let</em> 声明就会导致抛出错误。例如：</p><ul><li>循环中的绑定块作用域的妙用</li></ul><p>开发者可能最希望实现 <em>for</em> 循环的块级作用域了，因为可以把声明的计数器变量限制在循环内。</p><h3 id="什么是自由变量" tabindex="-1"><a class="header-anchor" href="#什么是自由变量"><span>什么是自由变量</span></a></h3><p>首先认识一下什么叫做<strong>自由变量</strong> 。</p><p>如下代码中，<em>console.log(a)</em> 要得到 <em>a</em> 变量，但是在当前的作用域中没有定义 <em>a</em>（可对比一下 <em>b</em>）。当前作用域没有定义的变量，这成为自由变量 。</p><p>自由变量的值如何得到 ？</p><p>需要向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。</p><h3 id="什么是作用域链" tabindex="-1"><a class="header-anchor" href="#什么是作用域链"><span>什么是作用域链</span></a></h3><p>如果父级也没呢？</p><p>再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链 。</p><h3 id="关于自由变量的取值" tabindex="-1"><a class="header-anchor" href="#关于自由变量的取值"><span>关于自由变量的取值</span></a></h3><p>关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 10，而不是 20</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">show</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <em>fn</em> 函数中，取自由变量 <em>x</em> 的值时，要到哪个作用域中取 ？</p><p>要到创建 <em>fn</em> 函数的那个作用域中取，<strong>无论 <em>fn</em> 函数将在哪里调用</strong>。</p><p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切：<strong>要到创建这个函数的那个域”。作用域中取值，这里强调的是“创建”，而不是“调用”</strong>，切记切记，其实这就是所谓的&quot;静态作用域&quot;。</p><h2 id="作用域与执行上下文" tabindex="-1"><a class="header-anchor" href="#作用域与执行上下文"><span>作用域与执行上下文</span></a></h2><p>许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。</p><p>我们知道 <em>JavaScript</em> 属于解释型语言，<em>JavaScript</em> 的执行分为：解释和执行两个阶段，这两个阶段所做的事并不一样。</p><p><strong>解释阶段</strong></p><ul><li>词法分析</li><li>语法分析</li><li>作用域规则确定</li></ul><p><strong>执行阶段</strong></p><ul><li>创建执行上下文</li><li>执行函数代码</li><li>垃圾回收 <em>JavaScript</em> 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。</li></ul><p>执行上下文最明显的就是 <em>this</em> 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p><p>作用域和执行上下文之间最大的区别是：</p><p><strong>执行上下文在运行时确定，随时可能改变，作用域在定义时就确定，并且不会改变</strong>。</p>`,49),o=[p];function l(i,c){return e(),a("div",null,o)}const u=n(t,[["render",l],["__file","8、作用域和作用域链.html.vue"]]),d=JSON.parse('{"path":"/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/%E6%B8%A1%E4%B8%80%E5%89%8D%E7%AB%AF/8%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html","title":"8、作用域和作用域链.md","lang":"zh-CN","frontmatter":{"category":["JS基础"],"description":"8、作用域和作用域链.md 作用域（Scope） 什么是作用域 作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。 换句话说，作用域决定了代码区块中变量和其他资源的可见性。 作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 ES6 之前 JavaScript 没有...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/%E6%B8%A1%E4%B8%80%E5%89%8D%E7%AB%AF/8%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.html"}],["meta",{"property":"og:site_name","content":"ErWin的博客"}],["meta",{"property":"og:title","content":"8、作用域和作用域链.md"}],["meta",{"property":"og:description","content":"8、作用域和作用域链.md 作用域（Scope） 什么是作用域 作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。 换句话说，作用域决定了代码区块中变量和其他资源的可见性。 作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。 ES6 之前 JavaScript 没有..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-10T07:11:45.000Z"}],["meta",{"property":"article:author","content":"Mr.ErWin"}],["meta",{"property":"article:modified_time","content":"2024-04-10T07:11:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"8、作用域和作用域链.md\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-10T07:11:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.ErWin\\",\\"url\\":\\"https://gitee.com/destiny12327\\"}]}"]]},"headers":[{"level":2,"title":"作用域（Scope）","slug":"作用域-scope","link":"#作用域-scope","children":[{"level":3,"title":"什么是作用域","slug":"什么是作用域","link":"#什么是作用域","children":[]},{"level":3,"title":"全局作用域和函数作用域","slug":"全局作用域和函数作用域","link":"#全局作用域和函数作用域","children":[]},{"level":3,"title":"块级作用域","slug":"块级作用域","link":"#块级作用域","children":[]},{"level":3,"title":"什么是自由变量","slug":"什么是自由变量","link":"#什么是自由变量","children":[]},{"level":3,"title":"什么是作用域链","slug":"什么是作用域链","link":"#什么是作用域链","children":[]},{"level":3,"title":"关于自由变量的取值","slug":"关于自由变量的取值","link":"#关于自由变量的取值","children":[]}]},{"level":2,"title":"作用域与执行上下文","slug":"作用域与执行上下文","link":"#作用域与执行上下文","children":[]}],"git":{"createdTime":1712733105000,"updatedTime":1712733105000,"contributors":[{"name":"ma","email":"destiny0402@163.com","commits":1}]},"readingTime":{"minutes":4.91,"words":1473},"filePathRelative":"面试笔记/渡一前端/8、作用域和作用域链.md","localizedDate":"2024年4月10日","excerpt":"\\n<h2>作用域（<em>Scope</em>）</h2>\\n<h3>什么是作用域</h3>\\n<p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。\\n换句话说，作用域决定了代码区块中变量和其他资源的可见性。</p>\\n<p>作用域就是一个独立的地盘，让变量不会<strong>外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong>\\n<strong><em>ES6</em> 之前 <em>JavaScript</em> 没有块级作用域，只有全局作用域和函数作用域</strong>。</p>\\n<p><em>ES6</em> 的到来，为我们提供了“块级作用域”，可通过新增命令 <em>let</em> 和 <em>const</em> 来体现。</p>","autoDesc":true}');export{u as comp,d as data};
